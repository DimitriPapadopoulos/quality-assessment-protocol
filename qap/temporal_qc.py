
import scipy.stats as stats


def pass_floats(output_string):
    """Parse AFNI command STDOUT output strings and return the output values 
    as a list of floats.

    :type output_string: str
    :param output_string: An AFNI command standard output.
    :rtype: list
    :return: A list of float values.
    """

    lines = output_string.splitlines()
    values_list = []

    for l in lines:
        try:
            val = float(l)
            values_list.append(val)
        except:
            pass

    return values_list


def calculate_percent_outliers(values_list):
    """Calculate the percentage of outliers from a vector of values.

    :type values_list: list
    :param values_list: A list of float values.
    :rtype: float
    :return: The percentage of values from the input vector that are
             statistical outliers.
    :rtype: float
    :return: The inter-quartile range of the data.
    """

    import numpy as np
    from qap.qap_utils import raise_smart_exception

    try:
        # calculate the IQR
        sorted_values = sorted(values_list)

        third_qr, first_qr = np.percentile(sorted_values, [75, 25])
        IQR = third_qr - first_qr

        # calculate percent outliers
        third_qr_threshold = third_qr + (1.5 * IQR)
        first_qr_threshold = first_qr - (1.5 * IQR)

        high_outliers = \
            [val for val in sorted_values if val > third_qr_threshold]
        low_outliers = \
            [val for val in sorted_values if val < first_qr_threshold]

        total_outliers = high_outliers + low_outliers

        percent_outliers = \
            float(len(total_outliers)) / float(len(sorted_values))

    except:
        raise_smart_exception(locals())

    return percent_outliers, IQR


def fd_jenkinson(in_file, rmax=80., out_file=None, out_array=False):
    """Calculate Jenkinson's Mean Framewise Displacement (aka RMSD) and save 
    the Mean FD values to a file.

    - Method to calculate Framewise Displacement (FD) calculations
      (Jenkinson et al., 2002).
    - Implementation written by @ Krsna, May 2013.
    - Jenkinson FD from 3dvolreg's *.affmat12.1D file from -1Dmatrix_save
      option input: subject ID, rest_number, name of 6 parameter motion
      correction file (an output of 3dvolreg) output: FD_J.1D file
    - in_file should have one 3dvolreg affine matrix in one row - NOT the
      motion parameters.

    :type in_file: str
    :param in_file: Filepath to the coordinate transformation output vector
                    of AFNI's 3dvolreg (generated by running 3dvolreg with
                    the -1Dmatrix_save option).
    :type rmax: float
    :param rmax: (default: 80.0) The default radius of a sphere that
                 represents the brain.
    :type out_file: str
    :param out_file: (default: None) The filepath to where the output file
                     should be written.
    :type out_array: bool
    :param out_array: (default: False) Flag to return the data in a Python
                      NumPy array instead of an output file.
    :rtype: str
    :return: (if out_array=False) The filepath to the output file containing
             the Mean FD values.
    :rtype: NumPy array
    :return: (if out_array=True) An array of the output Mean FD values.
    """

    import numpy as np
    import os.path as op
    from shutil import copyfile
    import math
    from qap.qap_utils import raise_smart_exception

    if out_file is None:
        fname, ext = op.splitext(op.basename(in_file))
        out_file = op.abspath('%s_fdfile%s' % (fname, ext))

    # if in_file (coordinate_transformation) is actually the rel_mean output
    # of the MCFLIRT command, forward that file
    if 'rel.rms' in in_file:
        copyfile(in_file, out_file)
        return out_file

    try:
        pm_ = np.genfromtxt(in_file)
    except:
        raise_smart_exception(locals())

    original_shape = pm_.shape
    pm = np.zeros((pm_.shape[0], pm_.shape[1] + 4))
    pm[:, :original_shape[1]] = pm_
    pm[:, original_shape[1]:] = [0.0, 0.0, 0.0, 1.0]

    # rigid body transformation matrix
    T_rb_prev = np.matrix(np.eye(4))

    flag = 0
    X = [0]  # First timepoint
    for i in range(0, pm.shape[0]):
        # making use of the fact that the order of aff12 matrix is
        # "row-by-row"
        T_rb = np.matrix(pm[i].reshape(4, 4))

        if flag == 0:
            flag = 1
        else:
            M = np.dot(T_rb, T_rb_prev.I) - np.eye(4)
            A = M[0:3, 0:3]
            b = M[0:3, 3]

            FD_J = math.sqrt(
                (rmax * rmax / 5) * np.trace(np.dot(A.T, A)) + np.dot(b.T, b))
            X.append(FD_J)

        T_rb_prev = T_rb

    try:
        np.savetxt(out_file, np.array(X))
    except:
        raise_smart_exception(locals())

    if out_array:
        return np.array(X)
    else:
        return out_file


def variance_scale_then_mean_center(x, var_scale=False, mean_center=True):
    """
    Multiply vector x by scalar scale and then subtract the mean.

    :param x: vector to be operated on.
    :type var_scale: bool
    :param var_scale: whether variance should be scaled to 1
    :type mean_center: bool
    :param mean_center: whether the vector should be mean centered

    :return: scaled then centered vector
    """
    scaled_x = x.copy()
    if var_scale is True:
        scale = 1 / x.std()
        scaled_x = scale * x
    if mean_center is True:
        mu = scaled_x.mean()
        scaled_x = scaled_x - mu
    return scaled_x
